# TMS (Transport Management System) & WMS API

![Build Status](https://img.shields.io/github/actions/workflow/status/your-username/your-repo/test.yml?label=CI&logo=github)
![License](https://img.shields.io/badge/license-MIT-blue)
![TypeScript](https://img.shields.io/badge/TypeScript-5.0-3178C6?logo=typescript)

A high-performance API for Transport and Warehouse Management built with **Bun**, **ElysiaJS**, and **Prisma**. This repository provides REST endpoints, Prisma models, and domain logic for TMS (Trips, Shipments, Routes) and WMS (Products, Warehouses, Inventory).

## Features

- **High Performance**: Bun runtime + ElysiaJS for low-latency APIs
- **Modular Architecture**: Feature-based modules (Organizational, HR, Fleet, WMS, TMS, Clients, Finance)
- **Type Safety**: TypeScript throughout the codebase
- **Prisma ORM**: Strongly-typed database access with Prisma Client and extensions
- **Audit & Soft Delete**: Automatic audit logging and soft-delete behavior via Prisma extensions (`src/lib/prisma.ts`)
- **Business Logic**: Trip finite-state machine to ensure valid lifecycle transitions
- **Precision Math**: Decimal-based calculations for financials and weights (`src/utils/math.ts`)
- **Interactive Docs**: Swagger UI available at `/swagger`

## Requirements Specification

This section captures **non‑functional requirements**, **data requirements & business rules**, and **functional requirements** for the TMS/WMS domain. Each requirement has a short identifier to make it easy to reference in design, implementation and tests.

### 1. Non-Functional Requirements (Infrastructure & Technology)
- **NFR-01 (Database)**: Use **PostgreSQL** as the primary relational database.
- **NFR-02 (ORM & Types)**: Use **Prisma** (v7+) to generate the client and types for safe DB access.
- **NFR-03 (Runtime & Tooling)**: Use **Bun** (v1+) as runtime, package manager, test runner and bundler for performance and concise tooling.
- **NFR-04 (Performance)**: API endpoints should be low-latency (suitable for real-time trip updates and inventory queries).
- **NFR-05 (Security)**: Authenticate API requests (JWT or OAuth) and store password hashes (Argon2 or similar). Use HTTPS in production.
- **NFR-06 (Observability)**: Audit logging for CREATE/UPDATE/DELETE and sufficient metrics/logs to debug production issues.
- **NFR-07 (Data Consistency & Durability)**: Enforce ACID guarantees where needed (financials, inventory), and use database transactions for multi-step operations (e.g., allocate inventory & create shipment).

### 2. Data Requirements & Business Rules
Below are concise, testable rules for the main entities.

#### Entity: User
- **DR-01 (Identifier)**: Each user must have a UUID primary key generated by the system.
- **DR-02 (Uniqueness)**: `email` is required and unique.
- **DR-03 (Username)**: `username` should be required and unique where present.
- **DR-04 (Security)**: Store `password_hash` (never plaintext). Password resets must be done using tokens.
- **DR-05 (Roles & Permissions)**: Users have roles (e.g., `admin`, `dispatcher`, `driver`, `employee`) that control allowed actions.
- **DR-06 (Auditing)**: `createdAt` and `updatedAt` are required and maintained by the system.
- **DR-07 (Soft Delete)**: Users can be soft-deleted; records remain for audit unless purged.

#### Entity: Company & Branch
- **DR-08 (Ownership)**: A `Company` may have multiple `Branch` entities; every `Branch` belongs to exactly one `Company`.
- **DR-09 (Branch Uniqueness)**: Branch `name` must be unique per `Company`.
- **DR-10 (Association with Users)**: Branches have assigned Users (employees); a user may belong to one or more branches depending on business rules.

#### Entity: Vehicle
- **DR-11 (Identifier)**: Vehicles have UUID ids and unique `registration_number` or `vin`.
- **DR-12 (Capacity)**: Each vehicle has `weight_capacity` and optionally `volume_capacity` (decimals).
- **DR-13 (Status & Availability)**: Vehicles maintain status (e.g., `available`, `in_maintenance`, `on_trip`) and cannot be assigned to overlapping trips.

#### Entity: Trip
- **DR-14 (Identifier)**: Trips use UUIDs.
- **DR-15 (Mandatory Fields)**: `origin`, `destination`, `scheduledAt` or `plannedDeparture` must be provided.
- **DR-16 (Associations)**: A Trip must be associated with a `Vehicle` and a driver (`User` with driver role) when scheduled/started.
- **DR-17 (State Machine)**: Trips have a controlled state machine (e.g., `planned` -> `enroute` -> `delivered` | `cancelled`) and transitions are validated by business logic.
- **DR-18 (Capacity Enforcement)**: When assigning shipments to a trip, total weight/volume must not exceed vehicle capacity.
- **DR-19 (Single Active Trip)**: A vehicle may not have overlapping `enroute` trips—enforce by schedule checks or locking.

#### Entity: Shipment
- **DR-20 (Identifier)**: Shipments have UUIDs.
- **DR-21 (Association)**: Shipments are associated with a `Client`, an origin branch/warehouse, a destination address/branch, and optionally a `Trip` once scheduled.
- **DR-22 (Weights & Volume)**: Shipment `weight` and `volume` required and used for capacity checks.
- **DR-23 (Status & Auditing)**: Track shipment status (e.g., `pending`, `assigned`, `in_transit`, `delivered`, `returned`) and audit important events.

#### Entity: Product, Warehouse & Inventory
- **DR-24 (Product)**: Each Product has `id (UUID)`, `sku` (unique), `name`, `weight`, `dimensions` (optional), and `unit`.
- **DR-25 (Warehouse)**: Warehouses have locations, contacts and storage constraints.
- **DR-26 (Inventory Entries)**: Inventory records must maintain `quantity_on_hand`, `reserved_quantity`, and `available_quantity` = `on_hand - reserved`.
- **DR-27 (Inventory Consistency)**: Inventory changes must be ACID-safe and logged (adjustments, reservations, consumes).
- **DR-28 (Negative Quantities)**: Prevent negative `available_quantity`—reject operations that would make inventory negative.

#### Entity: Client & Finance
- **DR-29 (Client)**: Clients have UUID, unique business id or tax id, contact details, and billing information.
- **DR-30 (Invoice & Finance)**: Use `Decimal` for money fields; invoices relate to shipments and must have `amount`, `currency`, `status` and `issueDate`.
- **DR-31 (Validation)**: Financial amounts must be validated and cannot be negative; taxes/fees computed deterministically.

#### Cross-cutting Data Rules
- **DR-32 (Audit Logging)**: All business-critical changes (shipments status changes, inventory adjustments, invoice issuance) must be recorded in `SystemAuditLog`.
- **DR-33 (Timestamps)**: All records must have `createdAt` and `updatedAt` with timezone-aware timestamps.
- **DR-34 (Soft Delete)**: Soft delete should be the default for most domain entities to allow traceability; use hard delete only for GDPR-compliant erasures when required.

### 3. Functional Requirements (Relationships & Behavior)
- **FR-01 (User -> Company/Branch)**: A `Company` may contain multiple `Branch` entities; `Users` can be assigned to branches (0:N).
- **FR-02 (Driver -> Trips)**: A driver (User) can have multiple Trips (1:N), but cannot be booked on overlapping trips.
- **FR-03 (Vehicle -> Trips)**: A Vehicle may be assigned multiple trips over time (1:N) but must not be concurrently assigned to overlapping `enroute` trips.
- **FR-04 (Trip -> Shipments)**: A Trip can carry multiple Shipments (1:N); shipments assigned to a trip must respect vehicle capacity.
- **FR-05 (Warehouse -> Inventory)**: Warehouses contain Inventory entries for Products (1:N); Inventory operations include receive, reserve, pick, and adjust.
- **FR-06 (Client -> Shipments)**: A Client can have multiple Shipments (1:N); shipments belong to one client.
- **FR-07 (Shipment -> Invoice)**: Shipments may be invoiced; invoices may cover single or multiple shipments.
- **FR-08 (Auditing & Notifications)**: Major state transitions (e.g., `shipment -> in_transit`, `trip -> delivered`, inventory below threshold) must generate audit entries and optionally notifications.

> Notes:
> - Where strict consistency is required (financials, inventory), use DB transactions and optimistic/pessimistic locking patterns as appropriate.
> - The Trip finite-state machine resides in domain service logic and must be covered by tests to prevent invalid transitions.

## Why Bun & Elysia

- **Performance**: Bun gives a fast runtime and tooling consolidation.
- **Developer Experience**: Elysia provides a lightweight, type-safe framework for APIs.
- **Tooling**: Bun reduces dev dependency bloat (runtime, test runner, bundler).

## Table of Contents

1. Quickstart
2. Installation
3. Environment
4. Running Locally
5. Migrations & Prisma
6. Testing & CI
7. Docker
8. Project Structure
9. Contributing
10. License

---

## Quickstart

```bash
git clone <repo-url>
cd TMS
bun install
cp .env.example .env    # edit .env to set DATABASE_URL, PORT, etc.
docker-compose up -d
bun prisma migrate dev
bun dev
```
API: http://localhost:3000
Swagger: http://localhost:3000/swagger

## Installation

1. Install dependencies:

```bash
bun install
```

2. Generate Prisma client (if needed):

```bash
bun prisma generate
```

## Environment Variables

Create a `.env` file (or copy `.env.example`) and set the required variables.

Example `.env`:

```env
DATABASE_URL="postgresql://user:password@localhost:5432/tms_db?schema=public"
PORT=3000
# Optional
# JWT_SECRET=
```

## Running Locally

Start infrastructure (Postgres):

```bash
docker-compose up -d
```

Apply migrations and start the dev server:

```bash
bun prisma migrate dev
bun dev
```

## Scripts

- Start dev: `bun dev` (watch)
- Build: `bun run build` (produces `out/`)
- Test: `bun test` (uses `NODE_ENV=test`)

## Migrations & Prisma

- Apply migrations: `bun prisma migrate dev`
- Generate client: `bun prisma generate`

## Testing ✅

Run the full test suite:

```bash
bun test
```

Run tests in watch mode (Bun will re-run when files change):

```bash
bun test --watch
```

**Test framework & style**
- Tests use Bun's built-in test runner (`bun:test`) with `describe`, `it`, `expect`, and `mock` helpers.
- Tests commonly mock `src/lib/prisma` using `mock.module("../../lib/prisma", ...)` to isolate services/controllers from the real DB.

### Test suites (what they cover)
Below are the main test files and short descriptions (useful for maintainers):

**Services**
- `src/services/tms/trip.service.test.ts` — TripService: validates finite-state transitions (start/finish), driver status checks, and timestamp behavior (startTime/endTime).
- `src/services/tms/shipment.service.test.ts` — ShipmentOrderService: basic instantiation and service-level behavior.
- `src/services/finance/finance.service.test.ts` — InvoiceService: instantiation and basic invoice creation scaffolding.
- `src/services/fleet/vehicle.service.test.ts` — VehicleService: vehicle creation and payload passed to Prisma.
- `src/services/fleet/fuel.service.test.ts`, `src/services/fleet/maintenance.service.test.ts` — Fleet-related services (fuel logs, maintenance lifecycle).
- `src/services/organizational/*.service.test.ts` — Company, Branch, Role, User services: CRUD and business rules.
- `src/services/hr/*.service.test.ts` — Employee and Driver services: validations (driver license checks, employee creation).
- `src/services/wms/*.service.test.ts` — Product and Warehouse services: inventory-related validations.
- `src/services/clients/client.service.test.ts` — Client service: client creation and data integrity checks.

**Controllers**
- `src/modules/tms/trip.controller.test.ts` — TripController: tests endpoints (GET /trips, POST /trips, PUT /trips/:id/status, POST /trips/routes) using mocked services/prisma.
- `src/modules/tms/shipment.controller.test.ts` — Shipment endpoints.
- `src/modules/fleet/*.controller.test.ts` — Vehicle, Fuel, Maintenance controllers: confirm routing and response formats.
- `src/modules/wms/*.controller.test.ts` — Warehouse & Product controllers.
- `src/modules/hr/*.controller.test.ts` — Driver & Employee controllers.
- `src/modules/organizational/*.controller.test.ts` — Company, Branch, User, Role controllers.

**How tests are organized & best practices**
- Prefer mocking `prisma` (via `mock.module`) for unit tests to avoid DB dependency.
- Use service-level tests for business logic (Trip FSM, capacity checks, financial calculations using `Decimal`).
- Use controller tests to verify routing, request validation and integration between controllers and services.

**Adding new tests**
1. Add a `*.test.ts` file next to the service or controller you want to cover.
2. Mock `src/lib/prisma` when needed:

```ts
mock.module("../../lib/prisma", () => ({ prisma: { /* mocked methods */ } }));
```

3. Use `mock()` to set return values for specific calls and assert that Prisma methods are invoked with expected args.

---

## CI

Example CI steps to run on push (GitHub Actions):
- `bun install`
- `bun prisma generate`
- `bun test`

## Docker

Run the full stack (DB + app):

```bash
docker-compose up --build
```

## Project Structure

```
src/
├── index.ts
├── generated/prisma   # Prisma client & types
├── lib/
│   └── prisma.ts     # Prisma extensions: audit, soft-delete
├── modules/          # Feature modules (controllers)
├── services/         # Business logic and services
└── utils/            # Helpers (math, validation, etc.)
```

## Development Notes

- Use `Decimal` for financial/weight calculations (`src/utils/math.ts`).
- Trips are protected by a finite state machine to prevent invalid transitions.
- Prisma extensions include audit logging and soft-delete behavior for selected models.

## API Documentation

Interactive Swagger docs are available at `http://localhost:3000/swagger` once the server is running.

## Contributing

Contributions are welcome. Please:
- Open issues to discuss changes
- Send PRs with clear descriptions and tests
- Follow existing coding patterns and add/update tests for new behavior

## License

This project is licensed under the MIT License. See `LICENSE` for details.

---

If you want, I can also add a `.env.example`, `CONTRIBUTING.md`, or GitHub Actions workflow templates next. Say which you'd like me to add (e.g., "Add .env.example" or "Add GitHub Actions CI") and I’ll implement it.
